// Generated by CoffeeScript 1.10.0
(function() {
  var BuildingTask, BuildingTaskSchema, Counter, CounterSchema, LocalStrategy, Project, ProjectSchema, Schema, User, UserSchema, app, bodyParser, corser, crypto, exec, execFile, express, flash, getHash, mongoose, passport, session;

  express = require("express");

  mongoose = require("mongoose");

  passport = require("passport");

  flash = require("connect-flash");

  session = require("express-session");

  crypto = require("crypto");

  bodyParser = require("body-parser");

  exec = require("child_process").exec;

  execFile = require('child_process').execFile;

  app = express();

  corser = require('corser');

  app.use(corser.create());

  app.use(bodyParser());

  app.use(bodyParser.urlencoded({
    extended: true
  }));

  app.use(bodyParser.json());

  app.use(session({
    secret: '123jh4536kj63szd43asd3'
  }));

  app.use(flash());

  app.use(passport.initialize());

  app.use(passport.session());

  LocalStrategy = require("passport-local").Strategy;

  mongoose.connect('mongodb://localhost/croset');

  Schema = mongoose.Schema;

  UserSchema = new Schema({
    username: String,
    password: String,
    projects: [Number]
  }, {
    strict: false
  });

  ProjectSchema = new Schema({
    name: String,
    owner: String,
    screens: {
      type: Schema.Types.Mixed,
      "default": {
        "default": {
          elements: {},
          cards: [],
          sourceCode: "",
          name: "トップ",
          boxProperties: {}
        }
      }
    },
    defaultScreen: {
      type: String,
      "default": "default"
    },
    config: Schema.Types.Mixed,
    projectId: Number,
    valiables: Schema.Types.Mixed,
    scripts: Schema.Types.Mixed
  }, {
    strict: false
  });

  BuildingTaskSchema = new Schema({
    target: String,
    projectId: Schema.Types.Mixed
  }, {
    strict: false
  });

  CounterSchema = new Schema({
    count: Number,
    name: String
  });

  User = mongoose.model("User", UserSchema);

  Project = mongoose.model("Project", ProjectSchema);

  BuildingTask = mongoose.model("BuildingTask", BuildingTaskSchema);

  Counter = mongoose.model("Counter", CounterSchema);

  ProjectSchema.pre('save', function(next) {
    var self;
    self = this;
    if (self.projectId) {
      return next();
    } else {
      return Counter.findOne({
        name: "project"
      }, function(err, counter) {
        if (err) {
          return next(err);
        } else {
          self.projectId = counter.count;
          counter.count++;
          return counter.save(function(err) {
            if (err) {
              console.log("Failed", err);
            }
            return next();
          });
        }
      });
    }
  });

  passport.use(new LocalStrategy({
    usernameField: "username",
    passwordField: "password",
    passReqToCallback: true
  }, function(req, name, password, done) {
    return process.nextTick(function() {
      User = mongoose.model("User", UserSchema);
      return User.findOne({
        username: name
      }, function(err, user) {
        var hashedPassword;
        if (err) {
          return done(err);
        }
        if (!user) {
          req.flash("error", "ユーザーが見つかりませんでした。");
          req.flash("input_id", name);
          req.flash("input_password", password);
          return done(null, false);
        }
        hashedPassword = getHash(password);
        if (user.password !== hashedPassword && user.password !== password) {
          req.flash("error", "パスワードが間違っています。");
          req.flash("input_id", name);
          req.flash("input_password", password);
          return done(null, false);
        }
        return done(null, user);
      });
    });
  }));

  getHash = function(value) {
    var sha;
    sha = crypto.createHmac("sha256", "secretKey");
    sha.update(value);
    return sha.digest("hex");
  };

  passport.serializeUser(function(user, done) {
    user.password = "";
    return done(null, user);
  });

  passport.deserializeUser(function(serializedAccount, done) {
    User = mongoose.model("User", UserSchema);
    return User.findById(serializedAccount, function(err, user) {
      user.password = 0;
      return done(err, user);
    });
  });

  app.use(express["static"]("public"));

  app.post("/project", function(req, res) {
    var id, ref, ref1;
    id = req != null ? (ref = req.session) != null ? (ref1 = ref.passport) != null ? ref1.user._id : void 0 : void 0 : void 0;
    if (id) {
      User = mongoose.model("User", UserSchema);
      return User.findById(id, function(err, user) {
        var project;
        if (err) {
          console.log(err);
        }
        if (user) {
          project = new Project(req.body);
          return project.save(function(err, proj) {
            if (err) {
              return console.log(err);
            } else {
              user.projects.push(proj.projectId);
              user.save(function(err, us) {
                return res.send(proj);
              });
              req.session.passport.user.projects = user.projects;
              return req.session.save(function() {
                return req.session.reload(function() {});
              });
            }
          });
        }
      });
    }
  });

  app.put("/project", function(req, res) {
    Project.update({
      projectId: req.body.projectId
    }, req.body, {}, function(err) {
      if (err) {
        return console.log(err);
      }
    });
    return res.send("OK");
  });

  app.get("/project", function(req, res) {
    return Project.findOne(req.query, function(err, project) {
      if (project) {
        delete project["_id"];
      }
      return res.send(project);
    });
  });

  app["delete"]("/project", function(req, res) {
    Project.remove({
      projectId: req.body.projectId
    }, function(err, result) {
      var index, user;
      if (err) {
        return console.log(err);
      } else {
        user = req.session.passport.user;
        index = user.projects.indexOf(req.body.projectId);
        user.projects.splice(index, 1);
        User.findById(user._id, function(err, model) {
          if (err) {
            return console.log(err);
          } else {
            model.projects = user.projects;
            return model.save(function(err) {
              if (err) {
                return console.log(err);
              }
            });
          }
        });
        return req.session.save(function() {
          return req.session.reload(function() {});
        });
      }
    });
    return res.send("OK");
  });

  app.post("/signup", function(req, res, next) {
    var user;
    user = new User({
      username: req.body.username,
      email: req.body.email,
      password: req.body.password,
      projects: []
    });
    return user.save(function(err, user) {
      if (err) {
        return console.log(err);
      } else {
        return passport.authenticate("local", {
          successRedirect: "/#!/dashboard",
          failureRedirect: "/#!/login",
          failureFlash: true
        })(req, res, next);
      }
    });
  });

  app.get("/profile", function(req, res) {
    var ref, ref1;
    return res.send(req != null ? (ref = req.session) != null ? (ref1 = ref.passport) != null ? ref1.user : void 0 : void 0 : void 0);
  });

  app.post("/login", function(req, res, next) {
    return passport.authenticate("local", {
      successRedirect: "/#!/dashboard",
      failureRedirect: "/#!/login",
      failureFlash: true
    })(req, res, next);
  });

  app.get("/logout", function(req, res) {
    req.logout();
    return res.redirect("/");
  });

  app.get("/build", function(req, res) {
    var buildingTask;
    buildingTask = new BuildingTask({
      projectId: req.query.projectId,
      target: "zip"
    });
    buildingTask.save(function(err, buildingTask) {
      if (err) {
        return console.log(err);
      } else {
        return execFile("/home/develop/Croset/build.sh", [JSON.stringify(req.query), req.query.projectId + ".zip"], [], function(err, stdout, stderr) {
          if (err !== null) {
            console.log("Error:" + err);
            return;
          }
          if (stderr) {
            console.log("StdErr" + stderr);
            return;
          }
          return buildingTask.remove(function(err, buildingTask) {
            if (err) {
              return console.log(err);
            }
          });
        });
      }
    });
    return res.send("ok");
  });

  app["delete"]("/build", function(req, res) {
    exec("rm ./public/builded-projects/" + req.body.projectId + ".zip", {
      maxBuffer: 1024 * 10000
    }, function(err, stdout, stderr) {
      if (err !== null) {
        console.log("Error:" + err);
      }
      if (stderr) {
        return console.log("StdErr" + stderr);
      }
    });
    return res.send("OK");
  });

  app.get("/builded", function(req, res) {
    return BuildingTask.findOne(req.query, function(err, buildingTask) {
      if (err) {
        console.log(err);
      }
      return res.send(buildingTask);
    });
  });

  app.listen(3000, function() {
    return console.log("Server running at port 3000!");
  });

}).call(this);
